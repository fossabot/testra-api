package tech.testra.reportal.service.vulnerability

import org.springframework.stereotype.Service
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.core.publisher.toMono
import tech.testra.reportal.domain.entity.VulnerabilityAlert
import tech.testra.reportal.domain.valueobjects.ProjectType
import tech.testra.reportal.domain.valueobjects.VulnerabilityRiskLevel
import tech.testra.reportal.exception.ProjectNotFoundException
import tech.testra.reportal.exception.ProjectTypeIsNotSecurityException
import tech.testra.reportal.extension.flatMapManyWithResumeOnError
import tech.testra.reportal.extension.flatMapWithResumeOnError
import tech.testra.reportal.model.VulnerabilityAlertModel
import tech.testra.reportal.repository.IVulnerabilityAlertRepository
import tech.testra.reportal.repository.IVulnerabilityRepository
import tech.testra.reportal.service.interfaces.ITestExecutionService
import tech.testra.reportal.service.interfaces.ITestProjectService
import tech.testra.reportal.service.interfaces.IVulnerabilityAlertService

@Service
class VulnerabilityAlertService(
    private val _vulnerabilityAlertRepository: IVulnerabilityAlertRepository,
    private val _vulnerabilityRepository: IVulnerabilityRepository,
    private val _testProjectService: ITestProjectService,
    private val _testExecutionService: ITestExecutionService
) : IVulnerabilityAlertService {

    override fun getVulnerabilityAlertById(projectId: String, executionId: String, resultId: String): Mono<VulnerabilityAlert> =
        _testExecutionService.getExecutionById(projectId, executionId)
            .flatMapWithResumeOnError { _vulnerabilityAlertRepository.findById(resultId) }

    override fun getVulnerabilityAlertByProjectAndExecutionIds(projectId: String, executionId: String): Flux<VulnerabilityAlert> =
        _testExecutionService.getExecutionById(projectId, executionId)
            .flatMapManyWithResumeOnError { _vulnerabilityAlertRepository.findAll(projectId, executionId) }

    override fun createVulnerabilityAlert(
        projectId: String,
        executionId: String,
        vulnerabilityAlertModelM: Mono<VulnerabilityAlertModel>
    ): Mono<VulnerabilityAlert> {
        return _testProjectService.getProject(projectId)
            .switchIfEmpty(ProjectNotFoundException(projectId).toMono())
            .flatMap {
                if (it.projectType == ProjectType.SECURITY) {
                    vulnerabilityAlertModelM.flatMap {
                        val vulnerabilityAlertModel = it
                        _vulnerabilityRepository.findByName(it.name)
                            .flatMap {
                                val simulation = VulnerabilityAlert(projectId = projectId,
                                    executionId = executionId,
                                    riskLevel = VulnerabilityRiskLevel.valueOf(vulnerabilityAlertModel.riskLevel.toString()),
                                    description = vulnerabilityAlertModel.description,
                                    solution = vulnerabilityAlertModel.solution,
                                    otherInfo = vulnerabilityAlertModel.otherInfo,
                                    reference = vulnerabilityAlertModel.reference,
                                    urls = vulnerabilityAlertModel.urls.toDomainVO(),
                                    vulnerabilityRefId = it.id,
                                    vulnerabilityCategoryRefId = it.vulnerabilityCatId
                                )

                                _vulnerabilityAlertRepository.save(simulation.toMono())
                            }
                    }
                } else {
                    ProjectTypeIsNotSecurityException(projectId).toMono()
                }
            }
    }

    override fun deleteVulnerabilityAlertById(id: String): Mono<Void> = _vulnerabilityAlertRepository.deleteById(id)

    override fun count(): Mono<Long> = _vulnerabilityAlertRepository.count()
}